from dataclasses import dataclass
from typing import List
import numpy as np

"""
Main class to store a closed loop trajectory for analysis.
"""
@dataclass(frozen=True)
class ClosedLoopTrajectory:
	# Arguments required from constructor.
	state_trajectory : np.ndarray  # N x 5, [time (s), x (m), y(m), yaw(rad), v(m/s)]
	input_trajectory : np.ndarray  # N x 2, [longitudinal_accel (m/s^2), steering_angle (rad)]
	feasibility      : np.ndarray  # N x 1, if the corresponding problem was feasible
	solve_times      : np.ndarray  # N x 1, solve_time of corresponding problem (s)
	l_f              : float = 1.5 # length from center of gravity to front axle (m)
	l_r              : float = 1.5 # length from center of gravity to rear axle (m)

	# Automatically generated by __post_init__, not given as argument to constructor.
	N         : int        = field(init=False, repr=False) # horizon of trajectory
	lat_accel : np.ndarray = field(init=False, repr=False) # N x 1, lateral acceleration
	jerk      : np.ndarray = field(init=False, repr=False) # (N-1) x 2, (long_jerk, lat_jerk)
	curvature : np.ndarray = field(init=False, repr=False) # N x 1, curvature

	def __post_init__(self):
		if self.state_trajectory.shape[0] != \
		   self.input_trajectory.shape[0] != \
		   self.feasibility.shape[0]      != \
		   self.solve_times.shape[0]:
			raise ValueError("Fields state_trajectory, input_trajectory, feasibility, and solve_times have varying number of timestamps")

		if not np.allclose(self.state_trajectory[:,0], self.input_trajectory[:,0]):
			raise ValueError("State and input trajectory timestamps do not match")

		if self.l_f <= 0 or self.l_r <= 0:
			raise ValueError(f"Expected positive l_f : {self.l_f} and l_r : {self.l_r}")

		dts = np.diff( self.state_trajectory[:,0] )
		if np.any( np.isclose(dts, 0.) ) or np.any( dts < 0 ):
			raise ValueError(f"Expected only positive dts but encountered zero/negative dt: {np.amin(dts)}")

		self.N = self.state_trajectory.shape[0]

		beta = np.atan( self.l_r / (self.l_f + self.l_r) * np.tan(self.input_trajectory[:,1]) )
		self.curvature = np.sin(beta) / self.l_r

		self.lat_accel = self.curvature * np.square(self.state_trajectory[:, -1])

		long_jerk = np.diff(self.input_trajectory[:,0]) / dts
		lat_jerk  = np.diff(self.curvature) / dts * np.square(self.state_trajectory[:-1,-1]) + \
		                2 * self.curvature[:-1] * self.input_trajectory[:-1, 0] * self.state_trajectory[:-1, -1]
		self.jerk = np.column_stack((long_jerk, lat_jerk))

	def __str__(self):
		return f"Trajectory with {self.N} timestamps."

"""
Metrics Computation
"""
def time_to_complete(cl_traj : ClosedLoopTrajectory) -> float:
	start_time = cl_traj.state_trajectory[ 0,0]
	end_time   = cl_traj.state_trajectory[-1,0]
	return end_time - start_time

def max_lateral_acceleration(cl_traj : ClosedLoopTrajectory) -> float:
	return np.amax( np.abs(cl_traj.lat_accel) )

def max_longitudinal_jerk(cl_traj : ClosedLoopTrajectory) -> float:
	return np.amax( np.abs(cl_traj.jerk[:,0]) )

def max_lateral_jerk(cl_traj : ClosedLoopTrajectory) -> float:
	return np.amax( np.abs(cl_traj.jerk[:,1]) )

def feasibility_percent(cl_traj : ClosedLoopTrajectory) -> float:
	feasible_bool = cl_traj.feasibility.astype(np.bool)
	return np.sum(feasible_bool) / len(feasible_bool)

def get_average_solve_time(cl_traj : ClosedLoopTrajectory) -> float:
	# TODO: what is the solve time if the problem wasn't feasible?
	return np.mean( cl_traj.solve_times )

def get_min_dist_per_TV(cl_traj_ego : ClosedLoopTrajectory,
	                    cl_trajs_tv : List[ClosedLoopTrajectory]) -> List[float]:
	dmins_tv = [] # dmin (m) where list index corresponds to cl_trajs_tv

	# TODO: consider vehicle extent and yaw for Mahalanobis dist vs. Euclidean?
	for cl_traj_tv in cl_trajs_tv:
		if not np.allclose( cl_traj_ego.state_trajectory[:,0], cl_traj_tv.state_trajectory[:,0] ):
			raise ValueError("The timestamps between the ego agent and TV agent don't match")

		positions_tv  = cl_traj_tv.state_trajectory[:, 1:3]
		positions_ego = cl_traj_ego.state_trajectory[:, 1:3]
		dists_ego_tv  = np.linalg.norm(positions_ego - positions_tv, axis=-1)
		dmins_tv.append( np.amin(dists_ego_tv) )

	return dmins_tv

"""
Main class to hold scenario data and compute metrics.
"""
@dataclass(frozen=True)
class ScenarioResult:
	# Experiment setup / metadata fields:
	scenario_name : str
	policy_type   : str

	# Ego vehicle closed-loop trajectory:
	ego_closed_loop_trajectory  : ClosedLoopTrajectory

	# Target vehicle fields:
	tv_closed_loop_trajectories : List[ClosedLoopTrajectory]

	# Metric computation
	def compute_metrics(self):
		metric_dict = {}

		metric_dict["completion_time"]          = time_to_complete(self.ego_closed_loop_trajectory)
		metric_dict["max_lateral_acceleration"] = max_lateral_acceleration(self.ego_closed_loop_trajectory)
		metric_dict["max_longitudinal_jerk"]    = max_longitudinal_jerk(self.ego_closed_loop_trajectory)
		metric_dict["max_lateral_jerk"]         = max_lateral_jerk(self.ego_closed_loop_trajectory)
		metric_dict["feasibility_percent"]      = feasibility_percent(self.ego_closed_loop_trajectory)
		metric_dict["average_solve_time"]       = get_average_solve_time(self.ego_closed_loop_trajectory)
		metric_dict["dmins_per_TV"]             = get_min_dist_per_TV(self.ego_closed_loop_trajectory, \
			                                                          self.tv_closed_loop_trajectories)
		return metric_dict
